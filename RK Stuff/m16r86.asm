;----------------------------------------------------------------------------
; Монитор компьютера Радио-86РК
; Исходник взят:
; http://code.google.com/p/radio86/wiki/MonitorDisassembled
; Предназначен для трансляции ассемблером:
; 2500 A.D. 8085 Macro Assembler  -  Version 4.01a
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; Адреса регистров Периферийных БИС

; ППА К580ВВ55 D20 (клавиатура)
port_A_kbd			.equ	8000h		; Порт A клавиатуры
port_B_kbd			.equ	8001h		; Порт B клавиатуры
port_C_kbd			.equ	8002h		; Порт C клавиатуры
contr_reg_kbd		.equ	8003h		; Регистр управляющего слова клавиатуры

; ППА К580ВВ55 D14
port_A_D14			.equ	0A000h		; Порт A D14
port_B_D14			.equ	0A001h		; Порт B D14
port_C_D14			.equ	0A002h		; Порт C D14
contr_reg_D14		.equ	0A003h		; Регистр управляющего слова D14
 
; Контроллер ЭЛТ К580ВГ75
parametrs_VG75		.equ	0C000h		; Регистр параметров
control_VG75		.equ	0C001h		; Регистр команд (только запись)
status_VG75			.equ	0C001h		; Регистр состояния (только чтение)

; Контроллер ПДП К580ВТ57
addr_ch2_VT57		.equ	0E004h		; Регистр адреса канала 2
contr_ch2_VT57		.equ	0E005h		; Регистр управления канала 2
mode_VT57			.equ	0E008h		; Регистр режима контроллера ПДП
 
;----------------------------------------------------------------------------
; Стандартные константы
n_byte_of_vmem		.equ	(78*30)		; Количество байт в видео ОЗУ
RST_6_addr			.equ	30h			; Адрес перехода по команде RST 6 
sinc_byte			.equ	0E6h		; Синхробайт для чтения с магнитофона
st_const_read		.equ	2Ah			; Стандартная константа чтения с маг.
st_const_write		.equ	1Dh			; Стандартная константа записи на маг.
kb_click			.equ    5003h		; Щелчек от нажатия клавиши
beep				.equ	5F0h		; Звуковой сигнал
first_kb_delay		.equ	224			; начальная задержка автоповтора клавиатуры
stndr_kb_delay		.equ	64			; стандартная задержка автоповтора клавиатуры
bounce				.equ	21			; задержка для устранения
										; дребезга контактов клавиатуры
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; Для трансляции программы Монитор под нужный обьем памяти раскомментируйте
; соответствующую директиву (но не две одновременно).
;----------------------------------------------------------------------------
; Начало области переменных Монитора для ОЗУ 16кб					
; monitor_area:		.equ	3600h
;----------------------------------------------------------------------------
; Начало области переменных Монитора для ОЗУ 32кб					
monitor_area:		.equ	7600h

;----------------------------------------------------------------------------
; Описание области переменных Монитора

memory_top			.equ	monitor_area-1		; верхняя граница свободной памяти
cursor_addr			.equ	monitor_area+0		; адрес знакоместа, где находится курсор		
cursor_xy			.equ	monitor_area+2		; координаты курсора ст.-y мл.-x
AR2_seq				.equ	monitor_area+4		; номер байта в АР2 последовательности
pressed_key			.equ	monitor_area+5		; ff - нажата клавиша, 0 - не нажата
ruslat_flag			.equ	monitor_area+6		; флаг рус/лат 0 - лат, ff - рус
keyboard_context	.equ	monitor_area+9		; младший байт - код клавиши
												; старший байт - счетчик автоповтора
released			.equ	monitor_area+0Bh	; признак, что ни одна клавиша не нажата
temp_sp				.equ	monitor_area+0Dh	; временное хранение указателя стека
PC_storage			.equ	monitor_area+14h	; временное хранение реального адреса останова
HL_storage			.equ	monitor_area+16h	; временное хранение HL
BC_storage			.equ	monitor_area+18h	; временное хранение BC
DE_storage			.equ	monitor_area+1Ah	; временное хранение DE
SP_storage			.equ	monitor_area+1Ch	; временное хранение SP
AF_storage			.equ	monitor_area+1Eh	; временное хранение A и PSW
stop_addr			.equ	monitor_area+23h	; адрес останова отлаживаемой программы
byte_in_stop_adr	.equ	monitor_area+25h	; байт по адресу останова
jump_to_go			.equ	monitor_area+26h	; команда JMP (0C3h) для директивы G
one_parametr		.equ    monitor_area+27h	; Первый параметр в команде					
two_parametr		.equ    monitor_area+29h	; Второй параметр в команде					
three_parametr		.equ    monitor_area+2Bh	; Третий параметр в команде
two_par_present		.equ	monitor_area+2Dh	; Второй параметр присутствует = ff
data_sign			.equ	monitor_area+2Eh	; Полярность входных данных с магнитофона					
read_const_mag		.equ	monitor_area+2Fh	; Константа чтения с магнитофона
write_const_mag		.equ	monitor_area+30h	; Константа записи на магнитофон
memlim				.equ	monitor_area+31h	; верхний адрес свободной памяти 
kbd_buf				.equ	monitor_area+33h	; буфер клавиатуры на 32 байта
monitor_area_end	.equ	monitor_area+5Fh	; конец области переменных
stack_bott			.equ	monitor_area+0CFh	; дно стека
vid_mem				.equ	monitor_area+0D0h	; начало видеопамяти
end_vid_mem			.equ	vid_mem+n_byte_of_vmem	; конец видеопамяти

;----------------------------------------------------------------------------
; Этот адрес используется как обращение к расширению программы Монитор,
; которое так и не было реализовано. Из за упрощенного декодирования
; адреса ПЗУ в реальном РАДИО-86РК с ПЗУ в 2кб переход происходит
; на "холодный" старт Монитора (start)  
nowhere:			.equ	0F000h
; Расширять ПЗУ в РАДИО-86РК можно вниз, вплоть до адреса 0E000h (8кб)
; без каких либо схемотехнических изменений.

;----------------------------------------------------------------------------
					.org	0F800h

;----------------------------------------------------------------------------
; "Холодный" старт программы Монитор
start:				jmp		entry_start
					
;----------------------------------------------------------------------------
; Стандартные продпрограммы Монитора
getc:				jmp		entry_getc
inpb:				jmp		entry_inpb
putc:				jmp		entry_putc
outb:				jmp		entry_outb
temp:				jmp		entry_putc
kbhit:				jmp		entry_kbhit
hexb:				jmp		entry_hexb
puts:				jmp		entry_puts
scan_kbd:			jmp		entry_scan_kbd
getxy:				jmp		entry_getxy
curc:				jmp		entry_curc
inpblock:			jmp		entry_inpblock
outblock:			jmp		entry_outblock
chksum:				jmp		entry_chksum
video:				jmp		entry_video
getlim:				jmp		entry_getlim
setlim:				jmp		entry_setlim

;----------------------------------------------------------------------------
; Инициализация компьютера (Холодный старт)
entry_start:		mvi		a,8Ah		; Настройка ППА клавиатуры
					sta		contr_reg_kbd

; Настраеваем указатель стека
					lxi		sp,stack_bott

; Настраеваем отображение видеопамяти на телевизоре
; Это нужно делать в первую очередь, чтобы начать регенерацию ОЗУ после сброса
					call	entry_video

; Обнуляем массив служебных ячеек Монитора
					lxi		h,monitor_area
					lxi		d,monitor_area_end
					mvi		c,0
					call	run_F_command ; заполнить с HL по DE байтами из C

					lxi		h,stack_bott
					shld	SP_storage

; Выводим на экран начальное сообщение "РАДИО-86РК"
					lxi		h,Radio
					call	entry_puts

; Настраеваем отображение видеопамяти на телевизоре
					call	entry_video

; Устанавливаем верхнюю границу свободной памяти
					lxi		h,memory_top
					shld	memlim

; Устанавливаем константы по умолчанию для чтения и записи
; на магнитофон 
					lxi		h, (st_const_write.shl.8)+st_const_read
					shld	read_const_mag
					
; Установка кода команды JMP для директивы G
					mvi		a,0C3h
					sta		jump_to_go

;----------------------------------------------------------------------------
; Выход на промт (Горячий старт)
prompt_loop:
					lxi		sp,stack_bott		; Настроить указатель стека

					lxi		h,Prompt
					call	entry_puts		; Выдать на экран промт -->
; Здесь подразумевается, что после выхода из п/п в A всегда будет 0 
					sta		port_C_kbd		; Записать все 0 в порт C клавиатуры
					dcr		a				; Получить в A FFh 
					sta		port_C_D14		; Записать все 1 в порт C дополнительного ППА

;----------------------------------------------------------------------------
; Консольный процессор Монитора
; Ввод и выполнение команд Монитора
;----------------------------------------------------------------------------
					call	input_string
					lxi		h,prompt_loop
					push	h
					lxi		h,kbd_buf		; Указатель на символ команды во введенной строке
					mov		a,m				; Поместить его в A

; Выполняем команды без параметров
					cpi		'X'				; Это команда просмотра и изменения содержимого
					jz		print_regs		; регистров? Если да, то выполнить ее

					cpi		'U'				; Это резервная команда (?) Если да, то перейти
					jz		nowhere			; на расширение ПЗУ

; Получаем 3 параметра команды: 1 -> HL, 2 -> DE, 3 -> BC
; Если параметра нет, то регистровая пара = 0
					push	psw
					call	parser_param	; Анализируем параметры
					lhld	three_parametr	; Сохраняем третий параметр
					mov		c,l				; в BC
					mov		b,h
					lhld	two_parametr	; Второй параметр
					xchg					; в DE
					lhld	one_parametr	; Первый параметр в HL
					pop		psw

;----------------------------------------------------------------------------
; Выполняем остальные команды
;----------------------------------------------------------------------------
;----------------------------------------------------------------------------
; Команда D (Dump). Печать содержимого памяти в виде дампа
					cpi		'D'
					jz		run_D_command

;----------------------------------------------------------------------------
; Команда C (Compare). Сравнение двух областей памяти
					cpi		'C'
					jz		run_C_command

;----------------------------------------------------------------------------
; Команда F (Fill). Заполнение области памяти
					cpi		'F'
					jz		run_F_command
					
;----------------------------------------------------------------------------
; Команда S (Search). Поиск в заданной области памяти
					cpi		'S'
					jz		run_S_command

;----------------------------------------------------------------------------
; Команда T (Transfer). Пересылка области памяти
					cpi		'T'
					jz		run_T_command

;----------------------------------------------------------------------------
; Команда M (Modify). Изменение содержимого памяти
					cpi		'M'
					jz		run_M_command

;----------------------------------------------------------------------------
; Команда G (Go). Выполнение программы с заданного адреса
					cpi		'G'
					jz		run_G_command

;----------------------------------------------------------------------------
; Команда I (Input). Загрузка программы с магнитофона
					cpi		'I'
					jz		run_I_command

;----------------------------------------------------------------------------
; Команда O (Output). Выгрузка программы на магнитофон
					cpi		'O'
					jz		run_O_command

;----------------------------------------------------------------------------
; Команда L (literal). Печать содержимого памяти в символьном виде
					cpi		'L'
					jz		run_L_command

;----------------------------------------------------------------------------
; Команда R (Read). Загрузка программы с ROM диска дополнительного ППА
					cpi		'R'
					jz		run_R_command

;----------------------------------------------------------------------------
; Нераспознанная команда. Переход на расширение Монитора
					jmp		nowhere


;----------------------------------------------------------------------------
; Удаление предыдущего символа в команде
;----------------------------------------------------------------------------
back_kbd_buf:
					mvi		a,<kbd_buf		; Адрес первого символа
											; в буфере строки.
					cmp		l				; Если это первый символ,	
					jz		input_next		; то ничего не делать.
					push	h
					lxi		h,BackClr		; Затереть предыдущий
					call	entry_puts		; символ.
					pop		h
					dcx		h				; 
					jmp		kbd_buf_loop

;----------------------------------------------------------------------------
; Ввод строки с клавиатуры.
; Вводим максимум 31 символа с клавиатуры в специальный буфер.
; Особо обрабатываемые клавиши:
;       [<-] и [ЗБ] - удаление последнего символа
;               [.] - выход на промт
;              [ВК] - успешный возврат из п/п  
;----------------------------------------------------------------------------
input_string:
					lxi		h,kbd_buf		; указатель на начало буфера строки
input_next:
					mvi		b,0				; признак успешности ввода (?)
kbd_buf_loop:
					call	entry_getc		; получить символ с клавиатуры
					cpi		8				; это клавиша <- ?
					jz		back_kbd_buf	; если да, то удалить предыдущий символ
					cpi		7Fh				; это клавиша ЗБ ?
					jz		back_kbd_buf	; если да, то удалить предыдущий символ
					cnz		putc_fromA		; вывести символ в экран
					mov		m,a				; и в буфер строки
					cpi		0Dh				; это клавиша ВК ?
					jz		out_of_loop		; прекратить ввод
					cpi		'.'				; это точка?
					jz		prompt_loop		; выйти на промт
					mvi		b,0FFh
					mvi		a,<kbd_buf+1Fh	; проверка на заполненность
					cmp		l				; буфера
					jz		fail_exit		; если полон, то ошибка 
					inx		h				; переходим к
					jmp		kbd_buf_loop	; следующему символу
out_of_loop:
					mov		a,b				;
					ral
					lxi		d,kbd_buf		; DE - начало буфера
					mvi		b,0				; 
					ret
					
;----------------------------------------------------------------------------
; Вывод строки на экран.
;	Указатель на начало строки в HL.
;	Строка заканчивается нулевым байтом
;----------------------------------------------------------------------------
entry_puts:
					mov		a,m				; Поместить символ в A
					ana		a				; Это нулевой байт?
					rz						; Если да, то выйти.
					call	putc_fromA		; Если нет, то вывести на экран,
					inx		h				; перейти к следующему и
					jmp		entry_puts		; продолжить вывод.

;----------------------------------------------------------------------------
; Анализ параметров команд Монитора
parser_param:
					lxi		h,one_parametr		; Обнуляем область параметров
					lxi		d,one_parametr+(2*3)
					mvi		c,0
					call	run_F_command
					lxi		d,kbd_buf+1			; Указатель на второй символ
					call	str_to_parametr		; Получаем первый параметр
					shld	one_parametr		; Сохраняем его как первый
					shld	two_parametr		; и второй
					rc							; если больше ничего, то выходим
					
; Здесь вводится признак наличия второго параметра.
; Поскольку невведенные параметры у нас = 0, то признак указывает,
; что второй параметр введен и возможно равен нулю					
					mvi		a,0FFh				; признак наличия второго параметра 
					sta		two_par_present		; сохраняем в служ. ячейке
					call	str_to_parametr		; вводим второй параметр
					shld	two_parametr		; сохраняем его
					rc							;  если больше ничего, то выходим
					
					call	str_to_parametr		; вводим третий параметр
					shld	three_parametr		; сохраняем его
					rc							;  если больше ничего, то выходим
					
					jmp		fail_exit			; если еще что то есть, то ошибка

;----------------------------------------------------------------------------
; Обработка строки с hex числом (параметром) на которую указывает DE.
;	Результат в HL.
;   Признак C =0 если параметр был
;			C =1 если его не было
;----------------------------------------------------------------------------
str_to_parametr:
					lxi		h,0			; Для начала параметр = 0
next_char:
					ldax	d			; Получить символ из строки
					inx		d			; и перейти к следующему

					cpi		0Dh			; Если [ВК], то выход
					jz		idle_exit	; без изменений

					cpi		','			; Если запятая, то
					rz					; просто выход

					cpi		' '			; Пробел в параметрах
					jz		next_char	; игнорируется
					
					sui		'0'			; Получаем из кода символа цифру,
					jm		fail_exit	; если код < 30h, то ошибка
					cpi		0Ah			; Если цифра < 10,
					jm		add_char	; число готово

					cpi		11h			; Если код < 41h (A),
					jm		fail_exit	; то ошибка,
					cpi		17h			; или > 47h (F),
					jp		fail_exit	; тоже ошибка.
					sui		7			; корректируем цифры A - F

; Добавляем очередную цифру в число
add_char:
					mov		c,a			; Новую цифру помещаем в C
					dad		h			; число x 16
					dad		h
					dad		h
					dad		h
					jc		fail_exit	; Если много цифр, то ошибка
					dad	b				; прибавляем очередную цифру
					jmp		next_char	; переходим к следующей

; Выход без признака редактирования
idle_exit:
					stc				; Признак без изменений
					ret


;----------------------------------------------------------------------------
; Сравнение регистровых пар HL и DE
;	Если их содержимое равно, то устанавливается флаг Z
;----------------------------------------------------------------------------
cmp_hl_de:
					mov		a,h
					cmp		d
					rnz
					mov		a,l
					cmp		e
					ret

;----------------------------------------------------------------------------
; Проверка на окончание адреса + сканирование на нажатие [F4].
;----------------------------------------------------------------------------
end_of_adr_or_F4:	call	press_F4	; Проверка на F4

;----------------------------------------------------------------------------
; Подпрограмма инкремента текущего адреса.
;	С начала происходит сравнение текущего адреса в HL с конечным в BC.
;	Если они не равны, то инкримент HL и выход.
;	Если равны, то перейти к предыдущиму адресу возврата
;----------------------------------------------------------------------------
cmp_hl_de_loop:
					call	cmp_hl_de	; Сравниваем HL и DE
					jnz		end_of_oper
pre_adr_return:
					inx		sp			; Удаляем текущий адрес возврата
					inx		sp			; и переходим к предыдущему
					ret
end_of_oper:
					inx		h			; Переходим к следующему адресу
					ret
					
;----------------------------------------------------------------------------
; Проверка на команду стоп.
;	Подпрограмма применяется для выхода из затянувшейся по времени команды.
;	Так же можно использовать для приостановки вывода на экран удержание
;	клавиши [РУС/ЛАТ], поскольку она срабатывает при отпускании.
;	Если клавиша [F4] не нажата, происходит просто выход из подпрограммы.
;	Если нажата, то выход на промт с выдачей знака вопроса.
;----------------------------------------------------------------------------
press_F4:			call	entry_scan_kbd	; Получить код нажатой клавиши
					cpi		3				; Это клавиша [F4]?
					rnz						; Если нет, то удачно выходим
					call	entry_video		; Если да, то восстанавливаем
											; видео,
					jmp		fail_exit		; и выходим на промт со знаком
											; вопроса.
											
;----------------------------------------------------------------------------
; Переход на новую строку с отступом.
;	Подпрограмма перехода на новую строку с отступом для вывода адреса
;----------------------------------------------------------------------------
next_line_and_offset:
					push	h
					lxi		h,offset_
					call	entry_puts
					pop		h
					ret
					
;----------------------------------------------------------------------------
; Вывод байта на который указывает HL на экран в виде hex числа + пробел
;----------------------------------------------------------------------------
hexb_m_and_space:	mov		a,m 

; Выдать байт в виде hex числа + пробел
hex_byte_and_space:
					push	b
					call	entry_hexb
					mvi		a,' '
					call	putc_fromA
					pop b
					ret

;----------------------------------------------------------------------------
; Выполнение команды D Монитора.
;	Выдача на экран дампа в шестнадцатиричных кодах
;	В каждой строке выдается по 16 байт памяти
;   В начале выдается адрес первой ячейки в строке в виде 4-х
;	шестнадцатиричных цифр. Потом выдается содержимое первой ячейки
;	в виде 2-х шестнадцатиричных цифр, потом второй и т.д.
;	до 16 включительно. Потом выводятся следующие 16 ячеек тем же способом
;	и так до конечного адреса.
;	Адреса первой ячейки строки округляются до 0 в последней цифре адреса.
;----------------------------------------------------------------------------
run_D_command:
					call	type_addr_from_HL

D_command_loop:		call	hexb_m_and_space
					call	end_of_adr_or_F4
					mov		a,l
					ani		0Fh
					jz		run_D_command
					jmp		D_command_loop


;----------------------------------------------------------------------------
; Выполнение команды C Монитора.
;	Происходит последовательное сравнение батов начиная с ячейки обозначенной
;	первым параметром и ячейки с адресом обозначенной третим параметром,
;	потом оба адреса увеличиваются на 1 и сравнение опять продолжается, пока первый
;	адрес не превысит второй параметр. После этого выполнение команды прекращается.
;	На экран выводится только ячейки с разным содержимым. С начала строки
;	выводится первый адрес сравнения, потом содержимое по первому адресу,
;	потом содержимое по второму адресу.  
; 
;----------------------------------------------------------------------------
run_C_command:
					ldax	b					; Получить байт из второго адреса в A
					cmp		m					; Сравнить с байтом из первого адреса
					jz		byte_equal			; Если равны, то перейти к следующему
					call	type_addr_from_HL	; Иначе выдать адрес с новой строки
					call	hexb_m_and_space	; 
					ldax	b
					call	hex_byte_and_space

byte_equal:			inx		b
					call	end_of_adr_or_F4
					jmp		run_C_command

;----------------------------------------------------------------------------
; Выполнение команды F Монитора.
;	Происходит заполнение памяти байтами из третьего параметра,
;	начиная с области указанной первым параметром до адреса
;	указанного во втором параметре
;  
;----------------------------------------------------------------------------
run_F_command:
					mov		m,c
					call	cmp_hl_de_loop
					jmp		run_F_command

;----------------------------------------------------------------------------
; Выполнение команды S Монитора.
;	Выполняется поиск в области памяти начиная с адреса в первом параметре
;	и по адрес заданный во втором параметре. Ведется поиск байта из третьего
;	параметра. На экран выводятся адреса ячеек в которых содержится искомый
;	байт. Каждый адрес выводится с новой строки
;----------------------------------------------------------------------------
run_S_command:
					mov		a,c			; получить шаблон в A
					cmp		m
					cz		type_addr_from_HL		; вывести адрес
					call	end_of_adr_or_F4
					jmp		run_S_command
					
;----------------------------------------------------------------------------
; Выполнение команды T Монитора.
;	Выполняется последовательная пересылка байтов с адреса указанного
;	в первом параметре в ячейку указанную в третьем параметре. Потом
;	оба адреса увеличиваются на 1. Пересылка продолжается пока первый
;	адрес достигнет указанного во втором параметре
;----------------------------------------------------------------------------
run_T_command:
					mov		a,m			; переслать очередной 
					stax	b				; байт
					inx		b
					call	cmp_hl_de_loop	; проверить на конец
					jmp		run_T_command
					
;----------------------------------------------------------------------------
; Выполнение команды L Монитора.
;	Вывод на экран содержимого памяти в символьном виде.
;	В начале строки выводится адрес первой ячейки, потом последовательно
;	содержимое 16 ячеек памяти в виде символов. Непечатные символы
;	заменяются точками.
;----------------------------------------------------------------------------
run_L_command:		call	type_addr_from_HL	; Выводим на экран адрес с
												; новой строки с отступом.

next_literal:		mov		a,m					; Поместить байт в A.
					ora		a					; Если байт больше 7Fh 
					jm		type_dot			; то выдать точку.
					cpi		' '					; Символы с кодом < 20h
					jnc		type_literal		; управляющие, вместо них
												; тоже выводим точку.
type_dot:			mvi		a,'.'				; Загрузить в A код точки

type_literal:		call	putc_fromA			; Выдать код на экран.
					call	end_of_adr_or_F4
					mov		a,l
					ani		0Fh
					jz		run_L_command
					jmp		next_literal


;----------------------------------------------------------------------------
; Выполнение команды M Монитора.
;	На экран с новой строки выводится адрес и содержимое ячейки памяти
;	указанной в первом параметре. Остальные два параметра игнорируются.
;	Ожидается ввод двух шестнадцатиричных цифр нового содержимого ячейки.
;	Если ничего менять не нужно нажимаем [ВК]. Выдается адрес следующей ячейки
;	и т.д. Если нужно выйти из команды, необходимо нажать клавишу [.].
;	Если ввести неверную цифру произойдет немедленный выход из команды
;----------------------------------------------------------------------------
run_M_command:
					call	type_addr_from_HL	; Выдать адрес с новой строки.
					call	hexb_m_and_space	; Выдать содержимое ячейки.
					push	h
					call	input_string		; Вводим новое значение.
					pop		h
					jnc		next_addr
					
					push	h					; Если новое значение введено,
					call	str_to_parametr		; получаем его в HL,
					mov		a,l					; потом в A
					pop		h
					mov		m,a					; и заменяем значение.

next_addr:			inx		h					; Прейти к следующему
					jmp		run_M_command		; адресу.

					
;----------------------------------------------------------------------------
; Выполнение команды G Монитора.
;   Команда предназначена для запуска и отладки программ.
;   В качестве первого параметра задается адрес старта программы,
;   по которому и передается управление. Второй параметр это
;   адрес останова программы. После останова программы управление
;   передается на "горячий" старт Монитора (prompt_loop). 
;----------------------------------------------------------------------------
; Работа команды различается в зависимости от того, введен адрес
; останова или нет. Если не введен, регистры общего назначения
; заполняются из служебных ячеек (доступных по команде X) и
; управление передается по введенному адресу (первый параметр).
; Если же адрес останова введен (второй параметр), то по этому адресу
; записывается команда процессора RST 6, которая делает вызов
; подпрограммы по адресу 0030h. А здесь записывается команда
; процессора JMP return_address. Программа записанная начиная с
; этого адреса (см. ниже) сохраняет регистры в служебных ячейках
; Монитора (доступных по команде X) и выдав на экран адрес останова
; переходит на "горячий" старт Монитора (prompt_loop).
run_G_command:
					call	cmp_hl_de			; Был ли введен адрес останова?
					jz		no_stop_addr		; если нет, то перейти
; Настройка механизма останова программы через адрес 0030h					
					xchg						; Адрес останова в HL
					shld	stop_addr			; Сохранить его в служебной ячейке
					mov		a,m					; Получить байт по адресу останова
					sta		byte_in_stop_adr	; Сохранить его на время работы программы
					mvi		m,0F7h				; Поместить команду RST 6 по адресу останова
					mvi		a,0C3h				; Поместить команду JMP
					sta		RST_6_addr			; по адресу 0030h
					lxi		h,return_address	; Сохранить адрес возврата
					shld	RST_6_addr+1		; для этой команды
; Загрузка регистров из служебных ячеек Монитора.
; Запуск программы происходит через "крючек" JMP (jump_to_go) в служебных ячейках Монитора
no_stop_addr:
					lxi		sp,BC_storage		; Загружаем регистры
					pop		b					; через указатель
					pop		d					; стека
					pop		h					; SP загружается через HL
					pop		psw
					sphl						; Загружаем SP
					lhld	HL_storage			; Загружаем HL
					jmp		jump_to_go			; Запускаем программу


;----------------------------------------------------------------------------
; Выполнение команды R Монитора.
;	Загрузка блока информации из ПЗУ подключенного к дополнительному ППА D14.
;	Шина данных подключена к порту A. Шина адреса подключена к портам B и C.
;	Загрузка в ОЗУ усуществляется начиная с адреса указанного в первом
;	параметре, по адрес указанный во втором параметре. Третий параметр
;	указывает начальный адрес в ПЗУ.
;----------------------------------------------------------------------------
run_R_command:
					mvi		a,90h			; Настроить ППА D14
					sta		contr_reg_D14	; порт A на ввод, B,C на вывод.

read_loop:
					shld	port_B_D14		; Выдать текущий адрес ПЗУ.
					lda		port_A_D14		; Прочитать байт в A.
					stax	b				; Сохранить его по адресу в ОЗУ.
					inx		b				; Перейти к след. адресу ОЗУ
					call	cmp_hl_de_loop	; Проверка на конец.
					jmp		read_loop		; Если не конец, то продолжить.

;----------------------------------------------------------------------------
; Получить координаты курсора в HL
;----------------------------------------------------------------------------
entry_getxy:		lhld	cursor_xy		; Берем эти данные из
					ret						; специальной ячейки
;----------------------------------------------------------------------------
; Получить байт (символ) с экрана по адресу курсора в A.
;   В аккумулятор помещается байт с адреса ОЗУ экрана, на который указывает
;   курсор.
;----------------------------------------------------------------------------
entry_curc:
					push	h				; Адрес экранного байта, на
					lhld	cursor_addr		; который указывает курсор
					mov		a,m				; хранится в специальной
					pop		h				; служебной ячейке
					ret

;----------------------------------------------------------------------------
; Выполнение команды I Монитора.
;	Выполняется загрузка блока данных с магнитофона. В первом параметре
;	смещение относительно начального адреса записанного на ленте.
;	В качестве второго параметра можно указать константу чтения.
;----------------------------------------------------------------------------
run_I_command:
					lda		two_par_present		; Ввести код новой константы
					ora		a					; чтения.
					jz		no_change_cr		; Если 0, то ничего не меняем.
					mov		a,e			 		; Если не 0, то заменить
					sta		read_const_mag				; константу чтения.

no_change_cr:		call	entry_inpblock		; Читаем блок с магнитофона
					call	type_addr_from_HL	; Выводим адрес начала
					xchg
					call	type_addr_from_HL	; Выводим адрес конца из DE
					xchg
					push	b
					call	entry_chksum		; Считаем контрольную сумму
					mov		h,b					; Помещаем ее в HL
					mov		l,c
					call	type_addr_from_HL	; Выводим на экран правильную КС
					pop		d					; Получаем считанную в DE
					call	cmp_hl_de			; Сравниваем считанную с вычислинной
					rz							; Если равны, то выход,
					xchg						; если не равны, выводим
					call	type_addr_from_HL	; еще и считанную
												; и выдаем знак вопроса,
												; что значит ошибку.
;----------------------------------------------------------------------------
; Выход из команды с ошибкой
fail_exit:
					mvi		a,'?'				; Выдать на экран
					call	putc_fromA			; знак вопроса
					jmp		prompt_loop			; и выйти на промт

					
;----------------------------------------------------------------------------
; Ввод блока данных с магнитофона.
;       Входные данные  : HL - смещение
;       Выходные данные : HL - адрес начала
;                         DE - адрес конца
;                         BC - считанная контрольная сумма блока
; Подпрограмма выполняет ввод блока данных, сформированный директивой
; 'O' Монитора. Блок имеет следующую структуру:
;      - раккорд
;      - синхробайт
;      - начальный адрес
;      - конечный адрес
;      - собственно данные (N байт)
;      - раккорд
;      - синхробайт
;      - контрольная сумма 2 байта
; Адреса и контрольная сумма записываются старшими байтами вперед.
;----------------------------------------------------------------------------
entry_inpblock:
					mvi		a,0FFh				; признак поиска синхробайта
					call	input_W_BC			; вводим начальный адрес в BC
					push	h
					dad		b					; суммируем его
												; со смещением и помещаем в
					xchg						; DE
					call	input_W_BC_nosinc	; читаем конечный адрес
					pop		h					; суммируем его
					dad		b					; со смещением
					xchg						; меняем адреса местами
					push	h					; сохраняем начальный адрес в стеке
					call	input_array			; вводим массив данных
					mvi		a,0FFh				; признак поиска синхробайта
					call	input_W_BC			; вводим контрольную сумму в BC
					pop		h					; восстанавливаем начальный адрес


;----------------------------------------------------------------------------
; Настройка отображения на экране
;----------------------------------------------------------------------------
entry_video:
					push	h
; Настраеваем контроллер ЭЛТ ВГ75
					lxi		h,control_VG75		; Адрес регистра управления в HL
					mvi		m,0					; Подать команду Reset
					dcx		h					; Передать параметры:
					mvi		m,78-1				; 78 символов в строке,
					mvi		m,30-1				; 30 знакорядов в кадре,
; Задаем высоту символа: 10 строк
; Высота линии подчеркивания 10 строк (1 и последняя линии символа затемняются)
					mvi		m,((10-1).shl.4)^(10-1)
; Задаем режим отображения: 0 - без сдига номеров строк
; Атрибуты поля: не прозрачные
; Тип курсора: мигающее подчеркивание
; Количество символов в строчном синхроимпульсе: 8 интервалов (6 мкс) 
					mvi		m,(1.shl.7)^(1.shl.4)^((8/2)-1)
; Подаем команду начать отображение со следующими параметрами:
; Интервал между запросами ПДП: 7 символов
; Количество байт в пакете ПДП: 8					
					inx		h
					mvi		m,(1.shl.5)^(((7+1)/8).shl.2)^(3)
					mov		a,m					; (?)
; Теперь необходимо засинхронизироваться с началом кадра.
; Для этого используем регистр статуса ВГ75
; Бит IR статусного регистра устанавливается после начала последнего знакоряда в кадре.
; Как раз в это время и нужно загружать данные первого знакоряда на экране
wait_beg_of_frame:
					mov		a,m					; читаем статусный регистр ВГ75
					ani		20h					; Проверяем флаг IR
					jz		wait_beg_of_frame	; Если сброшен, ждем начала кадра
; Если флаг IR установлен, то достигнут конец кадра
; Настраеваем канал ПДП ВТ57
; Для пересылки используется канал 2 в режиме чтения ОЗУ с автозагрузкой.
; Для автозагрузки используются регистры канала 3. 					
; После пересылки последнего байта экрана начальные данные ПДП (начальный
; адрес и количество байт пересылки) снова автоматически загружаются в регистры
; 2 канала и пересылка продолжается постоянно
					lxi		h,mode_VT57			; Сначала останавливаем ПДП
					mvi		m,80h				; и включаем автозагрузку
; Настраеваем регистры 2 канала ПДП					
; Задаем адрес начала пересылки: начало видео ОЗУ
					mvi		l,<addr_ch2_VT57
					mvi		m,<vid_mem
					mvi		m,>vid_mem
; Задаем количество байт пересылки
; и режим: запись в ОЗУ
					inr		l
					mvi		m,<(n_byte_of_vmem-1)
					mvi		m,40h^>(n_byte_of_vmem-1)
; Запускаем ПДП со следующими параметрами:
;      Включаем режим автозагрузки.
;      Включить удлиненную запись.
;      Разрешить работу канала 2.					
					mvi		l,<mode_VT57
					mvi		m,0A4h

					pop		h					; Восстанавливаем HL
					ret							; и выходим

;----------------------------------------------------------------------------
; Ввод 16-битного слова в BC с магнитофона
;----------------------------------------------------------------------------
input_W_BC_nosinc:							; устанавливаем признак
					mvi		a,8				; без поиска синхробайта
					
; Отсюда идет вызов с поиском синхробайта,
; но в A предварительно нужно занести 0FFh		
input_W_BC:			call	entry_inpb		; читаем старший байт
					mov		b,a				
					mvi		a,8
					call	entry_inpb		; читаем младший байт
					mov		c,a
					ret
					
					
;----------------------------------------------------------------------------
; Чтение массива данных с магнитофона
;     Входные данные: HL - начальный адрес массива,
;                     DE - конечный адрес массива. 
;----------------------------------------------------------------------------
input_array:								; устанавливаем признак
					mvi		a,8				; без поиска синхробайта
					call	entry_inpb		; читаем очередной байт
					mov		m,a				; помещаем его в память
					call	cmp_hl_de_loop	; инкремент HL и
											; проверка на HL=DE
											; если равны, то выход
					jmp		input_array		; иначе продолжить ввод
				
				
;----------------------------------------------------------------------------
; Подсчет контронльной суммы
;      Входные данные: HL - начальный адрес массива,
;                      DE - конечный адрес массива. 
;     Выходные данные: BC - подсчитанная контрольная сумма
; Алгоритм расчета:
;      Младший байт: сумма всех байтов без учета переноса.
;      Старший байт: сумма всех байтов, кроме последнего + переносы
;                    из младшего байта
;----------------------------------------------------------------------------
entry_chksum:
					lxi		b,0				; Обнуляем заготовку под контрольную
											; сумму
checksum_loop:
; Обработка младшего байта
					mov		a,m				; помещаем очередной байт в A 
					add		c				; прибавляем к предыдущим
					mov		c,a				; и сохраняем в C
					push	psw				; сохраняем признак переноса
					call	cmp_hl_de		; это последний байт?
					jz		pre_adr_return	; если да, то достаем psw и выходим
					pop		psw				; восстанавливаем признак переноса
; Обработка старшего байта 
					mov		a,b				; помещаем его в A
					adc		m				; суммируем с очередным
											; байтом + перенос из младшего
					mov		b,a				; сохраняем в B
					call	cmp_hl_de_loop	; определяем последний байт
											; если последний, то выход из п/п
											; если не последний, то инкремент HL
					jmp		checksum_loop	; и продолжить подсчет
					
					
;----------------------------------------------------------------------------
; Выполнение команды O Монитора.
;	Запись на магнитную ленту блока памяти, начаная с адреса указанного
;	в первом параметре, по адрес указанный во втором параметре. В качестве
;	третьего параметра можно указать новую константу записи.
;----------------------------------------------------------------------------
run_O_command:		mov		a,c					; Проверить был ли третий параметр
					ora		a
					jz		no_change_cw		; Если был, то сохранить его
					sta		write_const_mag		; как новую константу записи

no_change_cw:		push	h					
					call	entry_chksum		; Вычисляем контрольную сумму в BC
					pop		h
					call	type_addr_from_HL	; Выводим начальный адрес 
					xchg
					call	type_addr_from_HL	; Выводим конечный адрес
					xchg
					push	h
					mov		h,b					; Перенисим к.с. в HL
					mov		l,c
					call	type_addr_from_HL	; Выводим контрольную сумму
					pop		h					; Возвращаем начальный адрес в HL

;----------------------------------------------------------------------------
; Вывод блока данных на магнитную ленту
;      Входные данные: HL - начальный адрес блока,
;                      DE - конечный адрес блока. 
;                      BC - подсчитанная контрольная сумма
; Структура выводимого блока:
;             - 256 байт (00) раккорда
;             - синхробайт
;             - начальный адрес блока
;             - конечный адрес блока
;             - собственно массив данных (N байт)
;             - раккорд 2 байта 00
;             - синхробайт
;             - контрольная сумма блока (2 байта)      
;----------------------------------------------------------------------------
entry_outblock:
					push	b				; сохраняем контрольную сумму
					lxi		b,0				; заготовка для вывода раккорда

; Выдача основного раккорда в 256 байт
; Раккорд определяется по характерному чистому тону в начале фонограммы					
raccord_loop:
					call	entry_outb		; выводим очередной байт раккорда
					dcr		b				; модифицируем счетчик байт раккорда
					xthl					; это холостые операции, вызывающие
					xthl					; задержку на 36 тактов ~20мкс
					jnz		raccord_loop	; если не последний байт, то продолжить

					mvi		c,sinc_byte			; Выдача синхробайта
					call	entry_outb
					
					call	out_addr_from_HL	; Выдача начального адреса блока

					xchg
					call	out_addr_from_HL	; Выдача конечного адреса блока
					
					xchg
					call	out_array_loop		; Выдача массима данных
					
					lxi		h,0
					call	out_addr_from_HL	; Выдача раккорда из 2 байт 00
					
					mvi		c,sinc_byte
					call	entry_outb			; Выдача синхробайта
					
					pop		h					; Восстанавливаем контрольную сумму
					call	out_addr_from_HL	; и выводим ее
					
					jmp		entry_video			; Восстанавливаем регенерацию
												; дисплея и выходим
											

;----------------------------------------------------------------------------
; Выдача адреса с новой строки с отступом в 4 символа.
;	Выводимый адрес в HL.
;----------------------------------------------------------------------------
type_addr_from_HL:
					push	b
					call	next_line_and_offset
					mov		a,h
					call	entry_hexb			; выдать старший байт 
					mov		a,l
					call	hex_byte_and_space	; младший + пробел
					pop		b
					ret

;----------------------------------------------------------------------------
; Выдача массива байт на магнитофон
;      Входные данные: HL - начальный адрес массива,
;                      DE - конечный адрес массива. 
;----------------------------------------------------------------------------
out_array_loop:
					mov		c,m					; Получить очередной байт
					call	entry_outb			; Выдать его на магнитофон
					call	cmp_hl_de_loop		; Проверить: HL=DE
												; Если да, то выйти
												; Если нет, то инкремент HL
					jmp		out_array_loop		; и продолжить вывод
					
;----------------------------------------------------------------------------
; Выдача 16 разрядного слова из HL на магнитофон
; Старший байт выводится первым.
;----------------------------------------------------------------------------
out_addr_from_HL:
					mov		c,h
					call	entry_outb			; Вывод старшего байта
					mov		c,l
					jmp		entry_outb			; Вывод младшего байта и выход
					
;----------------------------------------------------------------------------
; Ввод байта данных с магнитофона
;      Входные данные  : A = 8        	- (8- количество бит в байте) без синхробайта
;                        A = 80h - 0FFh - (отрицательное число) с поиском синхробайта
;      Выходные данные : A - введенный байт
; Если ввод был с поиском синхробайта, то выдается байт, следующий
; непосредственно за синхробайтом.
; Обработка последнего бита укорачивается на 450 тактов, что бы предоставить
; время на обработку введенного байта, до обработки следующего.
;----------------------------------------------------------------------------
entry_inpb:
					push	h					; Сохраняем контекст
					push	b
					push	d
					mov		d,a					; Сохраняем признак синхробайта

; Отслеживаем изменение уровня на входе магнитофона в отсутствие сигнала
lock_change:
					mvi		a,80h				; Останавливаем отображение
					sta		mode_VT57			; на экране

; Здесь указатель стека SP используется не традиционно
; для регенерации ОЗУ. Его содержимое записывается в служебной ячейке,
; а в SP записывается 0000h. Далее мы периодически выполняя инструкцию
; POP PSW, выполняем регенерацию ОЗУ. 
					lxi		h,0
					dad		sp					; Сохраняем указатель стека
					lxi		sp,0				; в служебной ячейке
					shld	temp_sp				; и обнуляем его

					mvi		c,0					; заготовка под вводимый байт
					lda		port_C_kbd			; прочитать состояние порта C
					rrc
					rrc
					rrc
					rrc							; Сдвинуть d5 --> d0
					ani		1					; сбросить остальные биты
					mov		e,a					; поместить результат в e
					
; Обработка очередного бита
next_bit:
					pop		psw					; регенерировать ОЗУ
					mov		a,c					; сдвигаем заготовку
					ani		7Fh					; принимаемого байта влево
					rlc							; на 1 бит и обнуляем
					mov		c,a					; бит d0
					mvi		h,0					; счетчик попыток чтения уровня

; Цикл ожидания изменения уровня на входе C4 DD20 (вход с магнитофона)
change_loop:
					dcr		h					; подсчет попыток чтения
					jz		if_not_change		; если это последняя, то обработать
					pop		psw					; регенерировать ОЗУ
					lda		port_C_kbd			; читаем состояние порта
					rrc
					rrc
					rrc
					rrc							; помещаем его в d0
					ani		1					; остальные сбрасываем
					cmp		e					; уровень изменился ?
					jz		change_loop			; если нет, ждем пока изменится

					ora		c					; если да, то помещаем
					mov		c,a					; очередной бит в заготовку
					dcr		d					; это последний бит?
					lda		read_const_mag		; читаем константу чтения
					jnz		normal_const		; пропуск, если не последний бит
					sui		12h					; сократить константу

normal_const:		mov		b,a					; подготовить счетчик задержки

; Цикл задержки чтения
;    Задержка на один проход цикла 10+5+10=25 тактов
;    что при тактовой частоте РК 16МГц составляет: Ft=16/9=1.7777МГц Tt=1/1.7777=0.56мкс
;    T=25*0.56мкс=14мкс
;    Для стандартной константы чтения Cr=2Ah=42 общая задержка составляет Tr=42*14мкс=591мкс или ~0.6мс
;    Для последнего бита Tl=(2Ah-12h)*14мкс=336мкс
read_delay_loop:
					pop		psw					; регенерировать ОЗУ
					dcr		b					; модифицировать счетчик задержки
					jnz		read_delay_loop		; продолжить, если не конец

					inr		d					; восстанавливаем счетчик бит
					lda		port_C_kbd			; читаем состояние порта
					rrc
					rrc
					rrc
					rrc							; помещаем его в d0
					ani		1					; остальные сбрасываем
					mov		e,a					; сохраняем введенный бит
					mov		a,d
					ora		a					; проверяем признак синхробайта
					jp		next_bit_load		; если нет, то считаем биты

; Проверка на наличие синхробайта
					mov		a,c					; берем введенный байт
					cpi		sinc_byte			; это синхробайт?
					jnz		invert_sinc			; проверим на инверсию
					xra		a					; если инверсии нет, то
					sta		data_sign			; устанавливаем полярность вх. сигнала
					jmp		set_bit_count		; и устанавливаем счетчик бит
invert_sinc:
					cpi		\sinc_byte			; это инверсный синхробайт?
					jnz		next_bit			; если, то ищем дальше синхробайт
					mvi		a,0FFh
					sta		data_sign			; устанавливаем инверсию вх. сигнала

; После получения синхробайта вводим еще и байт данных					
set_bit_count:		mvi		d,8+1				; Устанавливаем количество бит для ввода

next_bit_load:		dcr		d					; Подсчет бит, если ввод без синхробайта
					jnz		next_bit			; если не последний бит, продолжаем ввод

; Ввод байта данных закончен
; Восстанавливаем отображение на экране
; Задаем адрес начала видео ОЗУ для канала 2 ПДП
					lxi		h,addr_ch2_VT57
					mvi		m,<vid_mem
					mvi		m,>vid_mem
					inx		h
; Задаем количество байт пересылки
					mvi		m,<(n_byte_of_vmem-1)
					mvi		m,40h^>(n_byte_of_vmem-1)
; Начать отображение с параметрами ПДП 8 байт в пакете 7 интервалов между пакетами					
					mvi		a,27h
					sta		control_VG75
; Подать команду установить счетчики	(?)				
					mvi		a,0E0h
					sta		control_VG75
; Начать отображение					
					mvi		l,<mode_VT57
					mvi		m,0A4h
					
					lhld	temp_sp				; Восстановить
					sphl						; указатель стека

					lda		data_sign			; выдаем байт данных в a
					xra		c					; в соответствии с полярностью сигнала
					jmp		comm_exit			; восстанавливаем контекст и выходим
				
; Обработка ситуации, когда на входе нет сигнала (уровень не меняется) 
if_not_change:		lhld	temp_sp
					sphl						; восстанавливаем стек
					call	entry_video			; восстанавливаем отображение видео
					mov		a,d
					ora		a					; нужно ли ожидать синхробайт ?
					jp		fail_exit			; если нет, то ошибка
					call	press_F4			; проверяем на нажатие F4
					jmp		lock_change			; продолжаем искать смену уровня
										
;----------------------------------------------------------------------------
; Выдача байта из C на магнитофон.
;      Входные данные: C - выводимый байт
; Информация выводится последовательно начиная со старшего бита
; на вывод C0 D20 (Выход на магнитофон).
; Паралельно с выводом на C0, информация в неинвертированном виде выдается
; и на выводы C1-C3. К выводу C3 подключен светодиод РУС/ЛАТ, следовательно он
; будет светится при выводе битов 1 на магнитофон 
;----------------------------------------------------------------------------
entry_outb:
					push	h				; сохраняем контекст процессора
					push	b
					push	d
					push	psw
					
					mvi		a,80h			; останавливаем вывод на экран
					sta		mode_VT57

; Здесь указатель стека SP используется не традиционно
; для регенерации ОЗУ. Его содержимое сохраняется в HL,
; а в SP записывается 0000h. Далее мы периодически выполняя инструкцию
; POP PSW, выполняем регенерацию ОЗУ. 
					lxi		h,0
					dad		sp
					lxi		sp,0
					
					mvi		d,8				; инициализируем счетчик бит

; Выдача первого (инвертированного) периода бита
out_next_bite:
					pop		psw				; регенерировать ОЗУ
					mov		a,c				; помещаем выводимый байт в A
					rlc						; переносим очередной бит в d0
					mov		c,a				; сохраняем сдвинутый выводимый байт
					mvi		a,1				; заготовка для инверсии бита d0
					xra		c				; инвертировать выводимый бит				
					sta		port_C_kbd		; выдать бит на магнитофон
					lda		write_const_mag	; ввести константу записи
					mov		b,a				; поместить ее в B

; Цикл задержки вывода инвертированного периода бита
;    Задержка на один проход цикла 10+5+10=25 тактов
;    что при тактовой частоте РК 16МГц составляет: Ft=16/9=1.7777МГц Tt=1/1.7777=0.56мкс
;    T=25*0.56мкс=14мкс
;    Для стандартной константы записи Cw=1Dh=29 общая задержка составляет Tr=29*14мкс=406мкс или ~0.4мс
;    Эта задержка составляет половину периода вывода бита, значит период ~=0.8мкс
;    Частота колебаний при выводе однородных бит (00000... или 11111...) составляет 1.2кГц
;    При выводе чередующихся бит (0101010101....) частота в 2 раз ниже ~600Гц.
;    При выводе случайной последовательности бит выдается шумоподобный сигнал,
;    при этом спектр распределяется между этими двумя частотами.
out_bite_loop1:
					pop		psw				; регенерировать ОЗУ
					dcr		b				; модифицировать счетчик задержки
					jnz		out_bite_loop1	; продолжить если не конец
					
; Выдача второго (прямого) периода бита
					mvi		a,0				; маска без инверсии
					xra		c				; получить выводимый бит
					sta		port_C_kbd		; выдать его на магнитофон
					dcr		d				; модифицировать счетчик бит
					lda		write_const_mag	; получить константу записи
					jnz		its_notlast		; если это последний бит
					sui		0Eh				; то уменьшить константу на 15
its_notlast:		mov		b,a				; поместить ее в B

; Цикл задержки вывода прямого периода бита
out_bite_loop2:
					pop		psw				; регенерировать ОЗУ
					dcr		b				; модифицировать счетчик задержки
					jnz		out_bite_loop2	; продолжить если не конец
					
					inr		d				; проверить на
					dcr		d				; последний бит
					jnz		out_next_bite	; если не последний, то продолжить

; Окончание вывода байта					
					sphl					; восстанавливаем указатель стека
					
; Восстанавливаем вывод изображения на экран
; Задаем адрес начала видео ОЗУ для канала 2 ПДП
					lxi		h,addr_ch2_VT57
					mvi		m,<vid_mem
					mvi		m,>vid_mem
; Задаем количество байт пересылки
					inx		h
					mvi		m,<(n_byte_of_vmem-1)
					mvi		m,40h^>(n_byte_of_vmem-1)
; Начать отображение с параметрами ПДП 8 байт в пакете и 7 интервалов между пакетами					
					mvi		a,27h
					sta		control_VG75
; Подать команду установить счетчики	(?)				
					mvi		a,0E0h
					sta		control_VG75
; Начать отображение					
					mvi		l,<mode_VT57
					mvi		m,0A4h
					
					pop		psw				; регенерировать ОЗУ

; Выход с восстановлением регистров из стека
; Используется для экономии места двумя подпрограммами.
comm_exit:
					pop		d
					pop		b
					pop		h
					ret

;----------------------------------------------------------------------------
; Вывод на экран байта в шестнадцатиричной форме из A
;----------------------------------------------------------------------------
entry_hexb:
					push	psw				; Сохраняем байт в стеке
					rrc						; Берем старшую тетраду
					rrc
					rrc
					rrc
					call	hexb_tetr		; выводим на экран
					pop		psw				; восстанавливаем байт

; Выдача на экран тетрады в виде шестнадцатиричной цифры
hexb_tetr:			ani		0Fh				; выделяем только младшую тетраду
					cpi		10				; число > 10 ?
					jm		hexb_make_sym
					adi		7				; если да, то отнимаем 7
											; чтобы выйти на символы A - F
hexb_make_sym:
					adi		30h				; Преобразуем число в соответствующий
											; ему символ и выводим на экран.

; Вывод символа из A
putc_fromA:
					mov		c,a				; Просто переносим символ в C.

;----------------------------------------------------------------------------
; Вывод символа на экран из регистра C.
;      Входные данные: C - выводимый байт
;----------------------------------------------------------------------------
entry_putc:
					push	psw				; Сохраняем контекст
					push	b				; процессора
					push	d
					push	h
					
; Следующая команда используется для приостановки или прерывания вывода на экран
; Для приостановки необходимо удерживать клавишу [РУС/ЛАТ].
; Для прерывания нужно нажать клавишу [F4].					
					call	entry_kbhit		; Ждем отпускания клавиши РУС/ЛАТ

; Вводим адрес сохранения перед выходом в стеке
; Этот фрагмент кода (mov_cur_and_exit) необходим для сохранения параметров
; курсора в служебных ячейках Монитора перед выходом из подпрограммы.
; Такое сохранение необходимо при любом выходе из этой подпрограммы.					
					lxi		h,mov_cur_and_exit
					push	h

					
					lhld	cursor_xy		; координаты курсора 
					xchg					; в DE
					lhld	cursor_addr		; HL - адрес вывода на экран, куда
											; указывает курсор

; Проверяем: передается ли последовательность АР2 для смещения курсора?											
					lda		AR2_seq			; Читаем признак АР2 последовательности
					dcr		a				; Установить признаки
					jm		AR2_no			; АР2 не используется - признак 0
					jz		AR2_b1			; Передается 1 байт ("Y") - признак 1
					jpo		AR2_b2			; Передается 2 байт смещение по Y - признак 2

;----------------------------------------------------------------------------
; Обработка 3 байта в АР2 посследовательности
; Здесь передается смещение курсора по горизонтали X + 20h					
					mov		a,c				; Получаем из параметра
					sui		20h				; действительное значение
					mov		c,a				; смещения по X 

; Цикл смещения вправо
AR2_move_X_loop:
					dcr		c				; Модифицировать счетчик
					jm		idle_seq		; Если все, то выход
					push	b				; Сохранить BC
					call	move_to_right	; Переместится на одну позицию вправо
					pop		b				; Восстановить BC
					jmp		AR2_move_X_loop
					
; Сброс АР2 последовательности
idle_seq:
					xra		a				; Снять признак АР2 последовательности
					
update_and_exit:
					sta		AR2_seq			; Обновить признак АР2 последовательности
					ret						; и выйти
					
;----------------------------------------------------------------------------
; Последовательность АР2 исключена, проверяем служебные символы
AR2_no:
					mov		a,c				; сбросить старший байт
					ani		7Fh				; символа
					mov		c,a 
; Обработка управляющих символов дисплея					
					cpi		1Fh				; Это код символа СТР?
					jz		init_display	; если да, то обработать
					cpi		0Ch				; Это символ "курсор в начало экрана"? 
					jz		cursor_to_0_0	; Если да, то обработать
					cpi		0Dh				; Это символ ВК (возврат каретки)?
					jz		run_BK			; Если да, то обработать
					cpi		0Ah				; Это символ ПС (перевод строки)?
					jz		run_PS			; Если да, то обработать
					cpi		8				; Это символ "<-"?
					jz		move_to_left	; Если да, то обработать
					cpi		18h				; Это символ "->"?
					jz		move_to_right	; Если да, то обработать
					cpi		19h				; Это символ "стрелка вверх"?
					jz		move_up			; Если да, то обработать
					cpi		1Ah				; Это символ "стрелка вниз"?
					jz		move_down		; Если да, то обработать
					cpi		1Bh				; Это код символа АР2?
					jz		AR2_seq_beg		; Если да, то обработать
					cpi		7				; Это символ звукового сигнала?
					jnz		run_to_others	; Если нет, то перейти дальше
					
; Задать высоту и длительность звукового сигнала					
					lxi		b,beep
;----------------------------------------------------------------------------
; Подпрограмма выдачи звукового сигнала
;   Входные данные: B - задержка периода (высота тона)
;                   C - количество периодов (длительность)
; Формула для расчета параметров звука:
;   b=47/f
;   c=t/(b*0.021)
;   где: f - частота звука в кГц
;        t - длительность звука в милисекундах
;        b и c - искомые значения для регистров B и C (целая часть)
;   диапазоны значений    f :  47кГц - 184Гц
;   максимальные значения t :  32мс при f=8кГц
;                             256мс при f=1кГц 
;                              1.4с при f=184Гц
; Если нужны большие длительности, необходим повторный вызов
; с тем же значением b.   
; Звук формируется путем периодической смены уровня высокий/низкий
; на выходе INTE (разрешение прерывания) процессора с помощью
; инструкций EI - разрешение прерывания и
; DI - запрещение прерывания
;----------------------------------------------------------------------------
to_give_sound:
; Верхний полупериод
					mov		a,b				; Помещаем задержку периода в A
hi_beep_loop:
					ei						; На выход звука высокий уровень
					dcr		a				; модифицируем счетчик
					jnz		hi_beep_loop	; если не ноль, продолжить задержку

; Нижний полупериод
					mov		a,b				; Помещаем задержку периода в A
lo_beep_loop:
					di						; На выход звука низкий уровень
					dcr		a				; модифицируем счетчик
					jnz		lo_beep_loop	; если не ноль, продолжить задержку
					dcr		c				; модифицировать счетчик периодов
					jnz		to_give_sound	; продолжить если не ноль
					ret
					
;----------------------------------------------------------------------------
; Печать остальных (отображаемых) символов 
run_to_others:
					mov		m,c				; Выдать символ на экран
					call	move_to_right	; Перейти на следующую позицию
; Если курсор оказался в исходной позиции (начало верхней строки),
; то вернуть его в начало самой нижней строки и выполнить скроллинг					
					mov		a,d				; Поместить номер текущей позиции по Y в A
					cpi		3				; Это верхняя строка?
					rnz						; Если нет, то выйти.
					mov		a,e				; Поместить номер текущей позиции по X в A
					cpi		8				; Это первая позиция?
					rnz						; Если нет, то выйти.
					call	move_up			; Перейти на самую нижнюю строку

;----------------------------------------------------------------------------
; Выполнение управляющего символа ПС.
; Оно аналогично выполнению символа "стрелка вниз", за исключением случая,
; когда курсор находится в самой нижней строке.
; В этом случае происходит скроллинг (смещение) экрана вверх на 1 строку.
; При этом верхняя строка теряется, а нижняя очищается. 
run_PS:
					mov		a,d				; Поместить номер текущей позиции по Y в A
					cpi		3+25-1			; Курсор в самой нижней строке?
					jnz		move_down		; Если нет, то перейти на строку вниз
					push	h				; Если да, то сохранить
					push	d				; DE и HL
					
; Выполняется смещение экрана на 1 строку вверх, начиная с первой					
					lxi		h,vid_mem+(78*3)+8		; Адрес начала 1 строки экрана
					lxi		d,vid_mem+(78*(3+1))+8	; Адрес начала 2 строки экрана
					lxi		b,25*78			; Количество пересылаемых байт

; Цикл смещения экрана на 1 строку вверх
scroll_loop:
					ldax	d				; Помещаем нижний код в A
					mov		m,a				; Сохраняем его наверху
					inx		h				; Модифицируем оба
					inx		d				; указателя
					dcx		b				; Модифицировать счетчик байт
					mov		a,c				; Проверить его
					ora		b				; на ноль
					jnz		scroll_loop		; Если не ноль, то продолжить
					
					pop		d				; Восстановить
					pop		h				; регистры и выйти
					ret
					
;----------------------------------------------------------------------------
; Обработка 1 байта в АР2 посследовательности
; Это обязательно должен быть код символа Y - 59h
AR2_b1:
					mov		a,c				; Поместить код в A
					cpi		'Y'				; Это символ Y?
					jnz		idle_seq		; Если нет, то сброс АР2
					call	cursor_to_0_0
					mvi		a,2				; Устанавливаем 2 байт в АР2
					jmp		update_and_exit	; и выходим
					
;----------------------------------------------------------------------------
; Обработка 2 байта в АР2 посследовательности
; Здесь передается смещение курсора по вертикали Y + 20h					
AR2_b2:
					mov		a,c				; Получаем из параметра
					sui		20h				; действительное значение
					mov		c,a				; смещения по Y 
; Цикл смещения вниз
AR2_move_Y_loop:
					dcr		c				; Модифицировать счетчик
					mvi		a,4				; Установить признак (?)
					jm		update_and_exit	; Если последний, то выйти
					push	b				; Сохраняем BC
					call	move_down		; Переходим на строку вниз
					pop		b				; Восстанавливаем BC
					jmp		AR2_move_Y_loop	; Продолжаем смещение вниз
					
;----------------------------------------------------------------------------
; Перемещаем курсор и выходим из подпрограммы
mov_cur_and_exit:
					shld	cursor_addr			; Сохраняем адрес вывода
					xchg
					shld	cursor_xy           ; и координаты курсора
					mvi		a,80h				; Подаем команду "установить
					sta		control_VG75		; курсор" на ВГ75
					mov		a,l					; и передаем
					sta		parametrs_VG75		; новые координаты
					mov		a,h
					sta		parametrs_VG75
					
					pop h						; восстанавливаем
					pop d						; контекст процессора
					pop b						; и выходим
					pop psw
					ret
;----------------------------------------------------------------------------
; Был прочитан код символа АР2, необходимо прочитать АР2 последовательность.
; Реализована только одна АР2 последовательность:
; Установка курсора в заданные координаты
; АР2+'Y'+(x+20h)+(y+20h),
;   где  x - номер позиции в строке (0 - 63),
;        y - номер строки (0 - 24).
; Отсчет начинается с верхнего левого угла экрана.
;----------------------------------------------------------------------------
AR2_seq_beg:
					mvi		a,1				; Установить признак 1 байта
					jmp		update_and_exit ; последовательности и выйти
					
;----------------------------------------------------------------------------
; Обработка управляющего символа инициализации дисплея СТР.
; Выполняются следующие действия:
;   - вся экранная область ОЗУ (2342 байта) обнуляется,
;   - курсор устанавливается в нулевую позицию.
;  Очистка начинается с конечного адреса видео ОЗУ, с нижнего правого угла экрана.
;----------------------------------------------------------------------------
init_display:
					lxi		h,end_vid_mem	; Ввести в HL верхнюю границу видео ОЗУ
					lxi		d,(78*30)+1		; Установить количество байт очистки

; Цикл очистки дисплея				
clear_disp_loop:
					xra		a				; Обнуляем A
					mov		m,a				; Выдаем 0 в очередную ячейку видео ОЗУ
					dcx		h				; Модифицируем указатель на видео ОЗУ
					dcx		d				; Модифицируем счетчик
					mov		a,e				; Проверяем счетчик
					ora		d				; на 0
					jnz		clear_disp_loop	; Если не 0, то продолжить

;----------------------------------------------------------------------------
; Установка курсора в начальную позицию (левый верхний угол экрана).
; На самом деле курсор устанавливается в 8-ю позицию 3-й строки
cursor_to_0_0:
					lxi		d,308h 				; Установить начальную 
					lxi		h,vid_mem+(78*3)+8	; позицию дисплея
					ret
;----------------------------------------------------------------------------
; Перемещение курсора на одну позицию вправо
move_to_right:
					mov		a,e				; Поместить номер текущей позиции по X в A
					inx		h				; Модифицировать адрес видео ОЗУ курсора
					inr		e				; Увеличить позицию по X
					cpi		8+64-1			; Это самая правая позиция?
					rnz						; Если нет, то выйти
					mvi		e,8				; Если да, то перейти на крайне левую позицию
					lxi		b,-64			; Указатель на видео ОЗУ
					dad		b				; тоже отмотать на 64 позиции влево

;----------------------------------------------------------------------------
; Перемещение на одну строку вниз					
move_down:
					mov		a,d				; Поместить номер текущей позиции по Y в A
					cpi		3+25-1			; Это самая нижняя позиция?
					lxi		b,78			; Прибавка в адресе для нижней позиции
					jnz		not_in_bottom	; Если нет, то перейти
					mvi		d,3-1			; Если да, то задать верхнюю строку,
					lxi		b,-24*78		; И смещение для адреса в верхней строке
not_in_bottom:
					inr		d				; Перейти на новую строку,
					dad		b				; скорректировать адрес в соответствии
					ret						; со смещением и выйти.
					
;----------------------------------------------------------------------------
; Перемещение курсора на одну позицию влево
move_to_left:
					mov		a,e				; Поместить номер текущей позиции по X в A
					dcx		h				; Модифицировать адрес видео ОЗУ курсора
					dcr		e				; Уменьшить позицию по X
					cpi		8				; Это самая левая позиция?
					rnz						; Если нет, то выйти
					mvi		e,8+64-1		; Если да, установить самую правую позицию
					lxi		b,64			; и модифицировать адрес
					dad		b				; для самой правой позиции в строке

;----------------------------------------------------------------------------
; Перемещение на одну строку вверх					
move_up:
					mov		a,d				; Поместить номер текущей позиции по Y в A
					cpi		3				; Это самая верхняя строка?
					lxi		b,-78			; Ввести смещение адреса для позиции сверху
					jnz		not_in_top		; Если не верхняя, то перейти
					mvi		d,3+25			; Если да, то задать нижнюю строку
					lxi		b,24*78			; И смещение для адреса в нижней строке
not_in_top:
					dcr		d				; Перейти на новую строку,
					dad		b				; скорректировать адрес в соответствии
					ret						; со смещением и выйти.
					
;----------------------------------------------------------------------------
; Выполнение управляющего символа ВК.
; Происходит перевод курсора в самую левую позицию текущей строки
run_BK:
					mov		a,l				; Младший байт адреса в А
					sub		e				; Вычесть номер позиции в строке
					jnc		no_borrow		; Если заем, то уменьшить
					dcr		h				; старший байт на 1
no_borrow:			mov		l,a				; Сохранить новый младший байт адреса
					mvi		e,8				; Установить первую позицию в строке
					lxi		b,8				; Ввести смещение для первой позиции
					dad		b				; Получить адрес первой позиции в строке
					ret						; и выйти
					
;----------------------------------------------------------------------------
; Опрос состояния клавиатуры
;     Выходные параметры: A = 0FFh - клавиша нажата
;                         A = 0    - клавиша не нажата
; Эта подпрограмма реализует функцию автоповтора клавиатуры
; и устранения дребезга контактов. Для этого ведется специальный счетчик
; обращений и признак нажатия выдается только при определенном количестве
; обращений и постоянном удержании одной и той же клавиши. Код нажатой
; клавиши берется из служебной ячейки.
; 
;   Номер обращения      Обрабатываемое событие              ~задержка
;         21             Устранение дребезга контактов      (161+?)*21
;       21+224           Начальная задержка автоповтора     (161+?)*224
;    21+224+64*N         Стандартный период автоповтора     (161+?)*64
; N = 1,2,3 и т.д.
;
; Стандартная задержка между обращениями к подпрограмме составляет 31 такт. 
;----------------------------------------------------------------------------
entry_kbhit:
; Проверка на нажатие клавиши [РУС/ЛАТ] 
					lda		port_C_kbd			; Читаем из порта C D20
					ani		80h					; берем только [РУС/ЛАТ]
					jz		rus_lat_not_press	; если отпущена, продолжаем
					lda		pressed_key			; Если нажата, проверяем
					ora		a					; на нажатую ранее клавишу
					rnz							; если нажата, выходим
rus_lat_not_press:
					push	h					; освобождаем HL
					lhld	keyboard_context	; загрузить параметры автоповтора
					call	entry_scan_kbd		; Получить код нажатой клавиши
												; FE - если рус/лат
												; FF - если не нажата
					cmp		l					; сравнить со старым
					mov		l,a					; сохранить
					jz		retention			; если равны, то удержание

; Здесь определяется, что клавиша отпущена
key_is_released:	mvi		a,1					; Признак отпускания клавиши
					sta		released			; сохранить в служебной ячейке
					mvi		h,bounce			; задержка, для устранения
												; дребезга контактов

not_pr_exit:		xra		a					; Установить признак "Клавиша не нажата"

kbd_exit:			shld	keyboard_context	; Сохраняем параметры автоповтора
					pop		h					; восстанавливаем  HL
					sta		pressed_key			; 
					ret
					
;----------------------------------------------------------------------------
; Обработка удержания клавиши
retention:
					dcr		h					; Модифицировать счетчик задержки
					jnz		not_pr_exit			; если время не вышло, не нажата
					inr		a					; если ff
					jz		kbd_exit			; Выход если клавиша не нажата
					inr		a					; если fe
					jz		if_rus_lat			; обработать [РУС/ЛАТ]
					
; Здесь определяется, что нажата новая клавиша
					push	b
					lxi		b,kb_click			; выдать щелчек
					call	to_give_sound		; от нажатия клавиши
					pop		b
					
					lda		released			; прочитать признак ненажатия
					mvi		h,first_kb_delay	; установить начальную задержку
												; автоповтора
					dcr		a					; модифицировать
					sta		released			; и сохранить признак ненажатия
					jz		its_first			; если это удержание,
					mvi		h,stndr_kb_delay	; то ввести стандартную задержку
												; автоповтора
its_first:
					mvi		a,0FFh				; признак нажатия клавиши
					jmp		kbd_exit			; выйти с этим признаком
					
					
;----------------------------------------------------------------------------
; Обработка клавиши [РУС/ЛАТ]
; Далее следует бесконечный цикл ожидания отпускания клавиши [РУС/ЛАТ]
if_rus_lat:
					lda		port_C_kbd			; Читаем порт C D20
					ani		80h					; берем только [РУС/ЛАТ]
					jz		if_rus_lat			; ждем пока отпустится

; Инверсия признака рус/лат для эммитации кнопки с фиксацией
					lda		ruslat_flag 
					cma
					sta		ruslat_flag
					jmp		key_is_released
					
;----------------------------------------------------------------------------
; Подпрограмма ввода символа с клавиатуры
;      Выходные данные : A - введенный символ
; Подрограмма не возвращает управления пока не будет нажата и или
; удержана клавиша на клавиатуре и не выполнится задержки реализованные
; в предыдущей подпрограмме.
;----------------------------------------------------------------------------
entry_getc:
; Здесь организован бесконечный цикл ожидания нажатия клавиши
					call	entry_kbhit			; Читаем состояние клавиатуры
					ora		a					; устанавливаем признаки для A
					jz		entry_getc			; Если клавиша не нажата,
												; то ждать.
												
					xra		a					; сбрасываем признак
					sta		pressed_key			; нажатия клавиши
					lda		keyboard_context	; берем код из служебной ячейки
					ret							; и выходим
					
;----------------------------------------------------------------------------
; Опрос кода нажатой клавиши
;     Выходные параметры: A = 0FFh - клавиша не нажата
;                         A = 0FEh - нажата клавиша [РУС/ЛАТ]
;                    или  A = код символа нажатой клавиши
; Подпрограмма выполняет сканирование матрицы клавиатуры 8х8 и
; выдает код первой попавшейся нажатой клавиши. 
;----------------------------------------------------------------------------
entry_scan_kbd:
; Проверка на нажатие клавиши [РУС/ЛАТ]
					lda		port_C_kbd		; Читаем порт вспомагательных клавиш
					ani		80h				; выбираем только [РУС/ЛАТ]
					jnz		fast_kbd_contrl	; если не нажата, то дальше
					mvi		a,0FEh			; если нажата, то выдаем признак
					ret						; и выходим

; Быстрая проверка на нажатие клавиш
fast_kbd_contrl:	xra		a				; обнулить A
					sta		port_A_kbd		; все линии сканирования =0
					sta		port_C_kbd		; погасить рус/лат
					lda		ruslat_flag		; получить признак рус/лат в A
					ani		1				; установить разряд светодиода
											; в соответствии с рус/лат
					ori		6				; подготовить команду вывода
					sta		contr_reg_kbd	; выдать команда зажечь/погасить
											; светодиод рус/лат
					lda		port_B_kbd		; прочитать соотояние матрицы
					inr		a				; если хотя бы 1 клавиша нажата,
					jnz		key_is_press	; то A != 0FFh
					dcr		a				; если равно, то установить признак
					ret						; и выйти
					
; Обработка, если хотя бы одна клавиша нажата
; Выполняем сканарование матрицы
; Задаем начальные параметры
key_is_press:
					push	h				; сохраняем HL
					mvi		l,1				; Заготовка для байта сканирования
					mvi		h,8-1			; количество проходов для сканирования

; Цикл сканирования столбцов матрицы (используется порт A D20) 											
scan_kbd_loop:
					mov		a,l				; сдвигаем заготовку для сканирования
					rrc
					mov		l,a
					cma
					sta		port_A_kbd		; активируем очередную шину сканирования
					lda		port_B_kbd		; читаем состояния клавиш
					cma
					ora		a				; если хоть одна из клавиш нажата
					jnz		scan_bounce		; то обслужить
					dcr		h				; модификация счетчика проходов
					jp		scan_kbd_loop	; если на последний,
											; то продолжить сканирование

; Клавиша не нажата или дребезг контактов
not_press:
					mvi		a,0FFh			; Устанавливаем признак
					pop		h				; ненажатия и выходим
					ret
					
; Устранение дребезга контактов
; Происходит путем опроса нажатия 32 раза
; Если хотя бы 1 раз не будет подтверждения нажатия,
; то клавиша считается ненажатой 
scan_bounce:
					mvi		l,32			; Инициализируем счетчик количества
											; опросов
scan_boun_loop:
					lda		port_B_kbd		; Читаем состояние клавиш
					cma
					ora		a				; Если не нажаты,
					jz		not_press		; то выйти
					dcr		l				; модифицировать счетчик опроса
					jnz		scan_boun_loop	; если не последний, то продолжить
					
					mvi		l,8				; задаем количество клавиш в столбце

;----------------------------------------------------------------------------
; Эта часть подпрограммы производит дешифрацию скан кода клавиш
; и присваивает ей определенный код, при этом используются
; клавиши модификаторы УС СС и РУС/ЛАТ
;----------------------------------------------------------------------------
; Таблица скан кодов клавиатуры РК
;------------------------------------------------------------------
; Клавиша :                      Столбец                          :
;    в    :--------------------------------------------------------
; столбце :  0   :  1   :  2   :  3   :  4   :  5   :  6   :  7   :
;------------------------------------------------------------------
;    0    : |- 00:    00: 0  30: 8  38: Ю  40: Х  48: П  50: Ь  58:
;         : |\   : ТАБ  :      : (    : @    : H    : P    : X    :
;------------------------------------------------------------------
;    1    :    01:    01: 1  31: 9  39: А  41: И  49: Я  51: Ы  59:
;         : СТР  : ПС   : !    : )    : A    : I    : Q    : Y    :
;------------------------------------------------------------------
;    2    :    02:    02: 2  32: :  3A: Б  42: Й  4A: Р  52: З  5A:
;         : AR2  : ВК   : "    : *    : B    : J    : R    : Z    :
;------------------------------------------------------------------
;    3    :    03:    03: 3  33: ;  3B: Ц  43: К  4B: С  53: Ш  5B:
;         : F1   : ЗБ   : #    : +    : C    : K    : S    : [    :
;------------------------------------------------------------------
;    4    :    04:    04: 4  34: ,  3C: Д  44: Л  4C: Т  54: Э  5C:
;         : F2   : <-   : $    : <    : D    : L    : T    : \    :
;------------------------------------------------------------------
;    5    :    05: ^  05: 5  35: -  3D: Е  45: М  4D: У  55: Щ  5D:
;         : F3   : |    : %    : =    : E    : M    : U    : ]    :
;------------------------------------------------------------------
;    6    :    06:    06: 6  36: .  3E: Ф  46: Н  4E: Ж  56: Ч  5E:
;         : F4   : ->   : &    : >    : F    : N    : V    : ^    :
;------------------------------------------------------------------
;    7    :    07:  | 07: 7  37: /  3F: Г  47: О  4F: В  57:    5F:
;         :      :  V   : ,    : ?    : G    : O    : W    :пробел:
;------------------------------------------------------------------
; Для столбцов 0 и 1 скан коды одинаковы потому, что перекодировка
; происходит табличным способом в отдельных ветках для каждого столбца.
; В столбцах 2 - 7 к номеру клавиши: 00SSSNNNb, где SSS - номер столбца,
; NNN - номер клавиши, прибавляется 20h, чтобы упростить декодирование 
;----------------------------------------------------------------------------
; Цикл определения номера клавиши в столбце
; Здесь из позиционного кода, считанного с порта B D20, мы
; получаем номер клавиши в столбце (начиная со старших номеров)
num_kbd_loop:
					dcr		l				; Уменьшаем счетчик номера
					rlc						; сдвигаем код влево через C
					jnc		num_kbd_loop	; дальше, если клавиша не нажата 
					
					mov		a,h				; меняем местами H <-> L
					mov		h,l				; через A
					mov		l,a
					
; Колонки 0 и 1 это управляющие символы, используемые в стандартных
; дисплеях. Для перекодировки используются специальные таблицы					
					cpi		1				; это 1 колонка
					jz		make_1_column	; если да, то обслужить
					jc		make_0_column	; обслужить 0 колонку
					
; Остальные клавиши используются для ввода отображаемых символов					
					rlc						; умножаем номер колонки
					rlc						; на 8 для получения
					rlc						; полного кода
					adi		20h				; Остальные коды начинаются с 30h
					ora		h				; прибавить номер кнопки колонке
					cpi		5Fh				; Это клавиша пробела?
					jnz		run_others		; Если нет, то продолжить
					mvi		a,20h			; Если да, то ввести в A код пробела
					pop		h				; восстановить HL и выйти
					ret
					
;----------------------------------------------------------------------------
; Это таблица перекодировки управляющих клавиш, подключенных к 0 столбцу
;----------------------------------------------------------------------------
column1table:		.db		9				; табуляция
					.db		0Ah				; перевод строки
					.db		0Dh				; возврат каретки
					.db		7Fh				; забой
					.db		8				; стрелка влево
					.db		19h				; стрелка вверх
					.db		18h				; стрелка вправо
					.db		1Ah				; стрелка вверх
;----------------------------------------------------------------------------
; Это таблица перекодировки управляющих клавиш, подключенных к 1 столбцу
;----------------------------------------------------------------------------
column0table:		.db		0Ch				; курсор в начало экрана
					.db		1Fh				; стереть экран
					.db		1Bh				; АР2
					.db		0				; F1
					.db		1				; F2
					.db		2				; F3
					.db		3				; F4
					.db		4				; F5 (этой клавиши нет),
					.db		5				; а этой и быть не может (?)
;----------------------------------------------------------------------------
; Обслуживание клавиш нулевой колонки
make_0_column:
					mov		a,h				; помещаем код клавиши в A (0-7)
					lxi		h,column0table	; HL - казатель на таблицу
					jmp		run_table
;----------------------------------------------------------------------------
; Обслуживание клавиш первой колонки
make_1_column:
					mov		a,h				; помещаем код клавиши в A (0-7)
					lxi		h,column1table	; HL - казатель на таблицу

run_table:
					add		l				; Получаем указатель на код в таблице (?)
					mov		l,a				; в HL
					mov		a,m				; получаем код в A
					cpi		40h				; Это клавиша ЗБ?
					pop		h				; если нет, то выйти
					rc
					
					push	h

;----------------------------------------------------------------------------
; Здесь происходит выдача кода для всех клавиш, кроме управляющих, [ЗБ] и пробела.
; Эти клавиши выдают 1 из 2-х символов в зависимости от состояния клавиш [СС], [УС]
; и режима рус/лат. Скан код клавиши находится в L, состояние клавиш [СС] и [УС] в H.
;----------------------------------------------------------------------------
run_others:
					mov		l,a				; Поместить скан код в L
					lda		port_C_kbd		; Прочитать вспомагательные клавиши
					mov		h,a				; сохранить в H
					ani		40h				; Выбрать только УС
					jnz		rus_or_lat		; Если не нажата, то дальше
					
; Обслуживание модификационной клавиши [УС].
; Она работает только с буквенными клавишами с кодом 40h - 5Fh.
; Если нажата одна из этих клавиш в сочетании с [УС], то
; выдается код на 30h меньше, т.е. 00h-1Fh (управляющие коды)
; Признак рус/лат на управляющие коды не влияет  
					mov		a,l				; поместить код в A
					cpi		40h				; Это буквы? 
					jm		not_press_YCCC	; Если нет, то ...
					ani		1Fh				; обнуляем старшие биты
					pop		h				; и выходим
					ret
					
; Выдача кода в зависимости от состояния рус/лат
; Действует только на буквенные клавиши со кодом  40h - 5Fh.
; Если признак рус/лат в состоянии лат (=0), то скан код = код.
; Если рус/лат = рус (=0FFh), то код больше от скан кода на 20h.
rus_or_lat:
					lda		ruslat_flag		; Получить признак раскладки
					ora		a				; установить флаги
					jz		run_CC			; Если не рус, то ничего не меняем		
					mov		a,l				; скан код в A
					cpi		40h				; Если не буквенная клавиша,
					jm		run_CC			; тоже ничего не меняем
					ori		20h				; если буквенная, то перевести
					mov		l,a				; все буквы в русский регистр

; Обслуживание модификационной клавиши [СС].
; Действие клавиши зависит от назначения (кода) клавиши.
; Буквенные клавиши меняют раскладку рус <-> лат
; Символьные и цифровые клавиши выдают один из 2-х символов
; которые она обозначает
;----------------------------------------------------------------------------
; 					
run_CC:
					mov		a,h				; Выделить состояние клавиши [СС]
					ani		20h				; в A
					jnz		not_press_YCCC	; Если не нажата, то ....
					mov		a,l				; Если нажата, то поместить код в A 
					cpi		40h				; 
					jm		not_press_CC	; клавиша цифровая или символьная?
					mov		a,l				; если нет, то перевести латинские
					xri		20h				; буквы в русские или наоборот,
					pop		h				; восстановить HL и выйти
					ret

not_press_CC:
					mov		a,l				; Если это не буквенная клавиша,
					ani		2Fh				; то сбрость ставший бит (?)
					mov		l,a

; Если модификационные клавиши УС и СС не нажаты
not_press_YCCC:
					mov		a,l				; Взять код клавиши
					cpi		40h				; Если это буква,
					pop		h				; то выйти
					rp
					
; Обработка цифровых и символьных клавиш					
					push	h				; 
					mov		l,a				; сохранить код в L
					ani		0Fh				; сбрасываем ненужные биты
					cpi		0Ch				; для клавиш с кодом
					mov		a,l				; 20h - 2Ch и 30h - 3Ch 
					jm		not_high		; меняются местами
					xri		10h				;
not_high:
					pop		h				; Восстановить HL
					ret						; и выйти
					
;----------------------------------------------------------------------------
; Определение верхней границы свободной памяти.
; Используется для программ, создающих в памяти буфер больших
; размеров (обычно текстовый).
; Если в ОЗУ необходимо разместить какую либо программу (резидентную или
; драйвер), ее размещают в верхней области (ниже служебной области Монитора),
; а границу верхней свободной памяти устанавливают на байт ниже.
; Это предотвратит затирание кода программы растущим буфером.
;----------------------------------------------------------------------------
entry_getlim:
					lhld	memlim			; Читаем значение из
					ret						; служебной ячейки
;----------------------------------------------------------------------------
; Установка верхней границы свободной памяти
;----------------------------------------------------------------------------
entry_setlim:
					shld	memlim			; Сохраняем значение
					ret						; в служебной ячейке
					
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
; Здесь хранятся различные строковые константы или сообщения.
; Примечание: Строковые константы всегда заканчиваются байтом =0
;----------------------------------------------------------------------------
;----------------------------------------------------------------------------
; Начальное сообщение, выводимое при инициализации компьютера
Radio:				.db		1Fh,"radio-86rk",0

;----------------------------------------------------------------------------
; Промт. Сообщение, указывающее, что монитор готов к вводу новой команды.
Prompt:				.db		0Dh,0Ah,"-->",0

;----------------------------------------------------------------------------
; Отступ для вывода адреса с новой строки
offset_:			.db		0Dh,0Ah,18h,18h,18h,18h,0

; Сообщение выдаваемое при выполнении команды X - просмотр и изменение
; регистров процессора для отладки. Сообщение состоит из 6 строк.
; После вывода курсор возвращается на 1 строку.
Regs:				.db		0Dh,0Ah," PC-"
					.db		0Dh,0Ah," HL-"
					.db		0Dh,0Ah," BC-"
					.db		0Dh,0Ah," DE-"
					.db		0Dh,0Ah," SP-"
					.db		0Dh,0Ah," AF-"
					.db		19h,19h,19h,19h,19h,19h,0

;----------------------------------------------------------------------------
; Это сообщение затирает предыдущий символ и ставит курсор на его место					
BackClr:			.db		8,20h,8,0

;----------------------------------------------------------------------------
; Адрес возврата из отлаживаемой программы.
; Выполняется только если в команде G Монитора (см. выше) указан адрес
; останова в качестве второго параметра.
; Содержимое регистров сохраняется в служебных ячейках Монитора.
; В последствии его можно просмотреть командой X Монитора.
; На экран выдается адрес останова. И управление передается на
; "горячий" старт Монитора (prompt_loop). 
return_address:
; Сначала сохраняем HL
					shld	HL_storage		; Сохраняем HL
					
; A и PSW сохраняем через стек и HL					
					push	psw				; Сохраняем A и PSW
					pop		h				; через стек и HL
					shld	AF_storage
					
; Возвращаем из стека реальный адрес останова, он может отличаться от
; указанного в команде G. Он сохраняется в стеке, поскольку мы
; используем команду RST 6, и больше на 1.					
					pop		h				; Берем реальный адрес останова
					dcx		h				; из стека 
					shld	PC_storage		; и сохраняем его
; Через HL получаем значение указателя стека и используя последний
; сохраняем значения всех остальных регистров					
					lxi		h,0				; Получаем значение
					dad		sp				; указателя стека в HL
					lxi		sp,SP_storage+2 ; Настраиваем SP
					push	h				; и сохраняем
					push	d				; все регистры
					push	b				; через стек
					
					lhld	PC_storage			; Берем адрес останова
					lxi		sp,stack_bott		; Настраиваем стек
					call	type_addr_from_HL	; Выдаем адрес останова на экран
					
; Проверяем, соответствует ли реальный адрес останова, введенному в команде G?					
					xchg
					lhld	stop_addr		; Берем адрес останова из команды G
					call	cmp_hl_de		; Сравниваем с реальным адресом останова
					jnz		prompt_loop		; Если не равны, то выходим
					
; Если они равны, восстанавливаем значение байта по этому адресу,
; сохраненное ранее командой G.					
					lda		byte_in_stop_adr	; Если равны, берем байт с адреса
					mov		m,a					; останова и восстанавливая его
					jmp		prompt_loop			; выходим
					
;----------------------------------------------------------------------------
; Выполнение команды X Монитора.
;   Выдается на экран содержимое регистров общего назначения (РОН)
;   процессора ВМ80 (в виде регистровых пар), хранящееся в служебных 
;   ячейках Монитора с возможностью изменения их содержимого.
;   Используется для отладочного запуска программ командой G Монитора.
print_regs:
					lxi		h,Regs				; Выдать на экран список имен 
					call	entry_puts			; РОН и перейти на самый верхний
					lxi		h,PC_storage		; Адрес первой служебной ячейки
					mvi		b,6					; Задать количество регистровых пар

; Цикл печати/изменения содержимого РОН
print_regs_loop:
					mov		e,m					; Поместить содержимое
					inx		h					; регистровой пары
					mov		d,m					; в DE
					push	b					; Сохранить регистры
					push	h					; в стеке
					xchg						; Поместить содержимое в HL
					call	type_addr_from_HL	; Выдать содержимое на экран
					call	input_string		; Ввести изменения с клавиатуры
					jnc		no_regs_change		; Если изменений нет, то перейти
					call	str_to_parametr		; Получить новое значение в HL
					pop		d					; Произвести обмен HL <-> DE
					push	d					; Через стек
					xchg
					mov		m,d					; Сохранить изменения
					dcx		h					; в служебной ячейке
					mov		m,e					; по тому же адресу

no_regs_change:
					pop		h					; Восстановить регистры
					pop		b					; из стека
					dcr		b					; Модифицировать счетчик регистров
					inx		h					; Перейти к следующей служебной ячейке
					jnz		print_regs_loop		; если не последний, то продолжить
					ret							; если последний регистр, то выйти
					
;----------------------------------------------------------------------------
; Эти 2 байта в программе не используются.
; В разных публикациях они выглядят по разному:

; Так они выглядят в журнале "Радио" №8 1986г. стр.24 
					.dw		0FFFFh
					
; Так на компьютере УМПК-Р-32, выпущеным Мукачевским приборостроительным заводом, 					
;					.dw		0FFh

; Так они выглядят в книге "Домашний компьютер" МРБ в.1139
; В. Г. Зеленко, В. В. Панов и С. Н. Попов, Радио и связь 1989г. стр.65,66
;					.dw		89BBh		; junk

					.end
